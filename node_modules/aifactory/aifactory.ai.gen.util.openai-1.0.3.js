/*
	AI factory | OPENAI
*/

var entityos = require('entityos')
var _ = require('lodash')
var moment = require('moment');

module.exports = 
{
	VERSION: '1.0.0',

	init: function (param)
	{
		
		// Using Agent SDK
		// Responses API
		// https://platform.openai.com/docs/libraries
		// https://cookbook.openai.com/examples/file_search_responses
		// /DEV.md file in this repo.

		entityos.add(
		{
			name: 'ai-gen-util-chat',
			code: function (param)
			{
				const settings = entityos.get({scope: '_settings'});

                let aiSettings = _.get(param, 'settings');
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');

				let apiKey = _.get(settings, keyPath);
                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const maxTokensDefault = _.get(settings, 'ai.defaults.maxtokens', 1000);
				const temperatureDefault = _.get(settings, 'ai.defaults.temperature', 0.7);

				const maxTokens = _.get(param, 'maxTokens', maxTokensDefault);
				const temperature = _.get(param, 'temperature', temperatureDefault);

				let messages = _.get(param, 'messages', {});

				//console.log('messages', messages)

                if (messages.user == undefined && messages.all == undefined)
                {
                    entityos.invoke('util-end', {error: 'No messages (all: or user:)!'});
                }
                else
                {
					let chatMessages;

					if (messages.all != undefined)
					{
						chatMessages = messages.all;
					}
					else
					{
						if (messages.system == undefined)
						{
							messages.system = _.get(aiSettings, 'ai.defaults.messages.system');
						}

						chatMessages = [
							{ role: 'system', content: messages.system }
						];
					}

					const attachments = _.get(param, 'attachments');
					
					if (attachments != undefined)
					{
						_.each(attachments, function (attachment)
						{
							if (attachment.base64 != undefined)
							{
								chatMessages.push(
								{
									role: 'user',
									content:
									[
										{ type: 'text', text: messages.user},
										{
											type: 'image_url',
											image_url:
											{
												url: 'data:image/png;base64,' + attachment.base64
											}
										}
									]
								});
							}

							if (chatMessages.url != undefined)
							{
								chatMessages.push(
								{
									role: 'user',
									content:
									[
										{ type: 'text', text: messages.user},
										{
											type: 'image_url',
											image_url:
											{
												url: attachment.url
											}
										}
									]
								});
							}
						});
					}

					if (messages.all == undefined && _.find(chatMessages, function (chatMessage) {return chatMessage.role == 'user'}) == undefined)
					{
						chatMessages.push({role: 'user', content: messages.user})
					}

					openai.chat.completions.create({
						model: aiSettings.model.name,
						messages: chatMessages,
						max_tokens: maxTokens,
						temperature: temperature
					})
					.then(function (completion)
					{
						_.set(param, 'messages.response', completion.choices[0]?.message?.content);

						if (_.get(param, 'onComplete') != undefined)
						{
							entityos._util.onComplete(param);
						}
						else
						{
							entityos.invoke('util-end', param);
						}
					})
					.catch(function (responseError)
					{
						_.set(param, 'messages.response',  '!!: ' + _.get(responseError, 'error.message'));

						if (_.get(param, 'onComplete') != undefined)
						{
							entityos._util.onComplete(param);
						}
						else
						{
							entityos.invoke('util-end', param);
						}

						//entityos.invoke('util-end', {error: _.get(responseError, 'error.message')});
					});
				}
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-service-models',
			code: function (param)
			{
				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				//console.log(aiSettings)

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				openai.models.list()
				.then(function(response)
				{
					let models = response.data;
					_.each(models, function (model)
					{
						model.isChat = (model.id.startsWith("gpt-") || model.id.includes("chat"))
					});

					const modelsChat = _.filter(models, function (model) {return model.isChat});
					const modelsChatSimple = _.filter(models, function (model) {return (model.isChat && _.split(model.id, '-').length <= 3)})

					//console.log(models);

					_.set(param, 'models', models);
					_.set(param, 'modelsChat', modelsChat);
					_.set(param, 'modelsChatSimple', modelsChatSimple);

					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', {data:
						{
							models: models,
							modelsChat: modelsChat,
							modelsChatSimple: modelsChatSimple
						}});
					}
				})
				.catch(function(err)
				{
					console.error("Error listing models:", err);
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-vector-stores',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });
	
				openai.vectorStores.list(
				{
					limit: 50, order: 'desc'
				})
				.then(function (vectorStores)
				{
					_.set(param, 'vectorstores', vectorStores.data);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end',
						{
							vectorstores: vectorStores.data
						});
					}
				})
				.catch(function(err)
				{
					console.error('Error getting vector stores:', err);

					entityos.invoke('util-end', {data:
					{
						vectorstores: {error: 'Error getting vector stores'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-vector-store-create',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const vectorStoreName = _.get(event, 'vectorstore.name');
		
				openai.vectorStores.create(
				{
					name: vectorStoreName,
				})
				.then(function (vectorStore)
				{
					_.set(param, 'vectorstore.id', vectorStore.id);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', {data:
						{
							vectorstore: {id: vectorStore.id}
						}});
					}
				})
				.catch(function(err)
				{
					console.error('Error creating vector store:', err);

					entityos.invoke('util-end', {data:
					{
						vectorstore: {error: 'Error creating vector store'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-vector-store-attach-file',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const file = _.get(event, 'file');
				const vectorStore = _.get(event, 'vectorstore');

				openai.vectorStores.files.create(vectorStore.id,
				{
					file_id: file.id
				})
				.then(function (vsFile)
				{
					//console.log('Attached vectorstore-file ID:', vsFile.id);
				
					_.set(param, 'vectorstorefile.id', vsFile.id);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', {data:
						{
							file: {id: vsFile.id}
						}});
					}
				})
				.catch(function(err)
				{
					console.error('Error uploading file:', err);

					entityos.invoke('util-end', {data:
					{
						file: {error: 'Error attaching file to vector store'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-files',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const vectorstore = _.get(event, 'vectorstore');

				console.log('id', _.get(vectorstore, 'id'));

				let _files = openai.files;

				if (_.get(vectorstore, 'id') != undefined)
				{
					_files = openai.vectorStores.files
				}

				_files.list(_.get(vectorstore, 'id'),
				{
					limit: 50, order: 'desc'
				})
				.then(function (files)
				{
					_.set(param, 'files', files.data);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end',
						{
							files: files.data
						});
					}
				})
				.catch(function(err)
				{
					console.error('Error getting files:', err);

					entityos.invoke('util-end', {data:
					{
						vectorstores: {error: 'Error getting files'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-file-upload',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const fs = require('fs');
				const path = require('path');

				const file = _.get(event, 'file');

				if (file.base64 != undefined)
				{
					const buffer = Buffer.from(file.base64, 'base64');
					file._pathFileName = path.join(__dirname, file.name);
					fs.writeFileSync(file._pathFileName, buffer);  // Save base64 as actual file
				}
				else
				{
					file._pathFileName = path.join(file.path, file.name);
				}	

				openai.files.create(
				{
					file: fs.createReadStream(file._pathFileName),
					purpose: 'assistants'
				})
				.then(function (file)
				{
					//file-UV5jQryNVC7TfuwuEpVXXi
					//console.log('Uploaded file:', file.id);

					if (file.base64 != undefined)
					{
						fs.unlinkSync(file._pathFileName);
					}

					_.set(param, 'file.id', file.id);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', {data:
						{
							file: {id: file.id}
						}});
					}
				})
				.catch(function(err)
				{
					if (file.base64 != undefined)
					{
						fs.unlinkSync(file._pathFileName);
					}

					console.error('Error uploading file:', err);

					entityos.invoke('util-end', {data:
					{
						file: {error: 'Error uploading file'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-assistant-create',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const assistantName = _.get(event, 'assistant.name');
				const assistantInstructions = _.get(event, 'assistant.instructions');
				const vectorStore = _.get(event, 'vectorstore');

				openai.beta.assistants.create(
				{
					name: assistantName,
					instructions: assistantInstructions,
					model: aiSettings.model.name,
					tool_resources: {
					file_search: {
						vector_store_ids: [vectorStore.id]
					}
					},
					tools: [{ type: 'file_search' }]
				})
				.then(function (assistant)
				{
					_.set(param, 'assistant.id', assistant.id);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', {data:
						{
							assistant: {id: assistant.id}
						}});
					}
				})
				.catch(function(err)
				{
					console.error('Error creating assistant:', err);

					entityos.invoke('util-end', {data:
					{
						vectorstore: {error: 'Error creating assistant'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-assistants',
			code: function (param)
			{
				const event = entityos.get({scope: '_event'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				openai.beta.assistants.list(
				{
					limit: 50, order: 'desc'
				})
				.then(function (assistants)
				{
					_.set(param, 'assistants', assistants.data);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end',
						{
							assistants: assistants.data
						});
					}
				})
				.catch(function(err)
				{
					console.error('Error getting assistants:', err);

					entityos.invoke('util-end', {data:
					{
						assistants: {error: 'Error getting assistants'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-thread-create',
			code: function (param)
			{
				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				openai.beta.threads.create()
				.then(function (thread)
				{
					_.set(param, 'thread.id', thread.id);
				
					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', {data:
						{
							thread: {id: thread.id}
						}});
					}
				})
				.catch(function(err)
				{
					console.error('Error creating thread:', err);

					entityos.invoke('util-end', {data:
					{
						thread: {error: 'Error creating thread'}
					}});
				});
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-thread-chat',
			code: function (param)
			{
				const data = entityos.get({scope: '_data'});

				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');
				
				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let keyPath = _.get(aiSettings, 'service.keypath');
				let apiKey = _.get(settings, keyPath);

                const OpenAI = require("openai");

                const openai = new OpenAI(
                {
                    apiKey: apiKey
                });

				const thread = _.get(data, 'thread');
				const assistant = _.get(data, 'assistant');
				const message = _.get(data, 'message');

				openai.beta.threads.messages.create(thread.id, message)
				.then(function ()
				{
					openai.beta.threads.runs.create(thread.id,
					{
						assistant_id: assistant.id
					})
					.then(function(run)
					{
						const poll = () => openai.beta.threads.runs.retrieve(thread.id, run.id)
						.then(status => {
							if (status.status === 'completed')
							{
								return openai.beta.threads.messages.list(thread.id)
								.then(messages => {
									const lastMessage = messages.data[0];
									const reply = lastMessage.content[0].text.value;
									//console.log('Assistant:', messages.data[0].content[0]);

									_.set(param, 'assistant.response', reply);
									//_.set(param, 'messages.response', reply);
				
									if (_.get(param, 'onComplete') != undefined)
									{
										entityos._util.onComplete(param)
									}
									else
									{
										entityos.invoke('util-end', {data:
										{
											assistant: {response: reply}
										}});
									}
								});
							}
							else if (['queued', 'in_progress'].includes(status.status))
							{
								setTimeout(poll, 1000);
							}
							else
							{
								//console.error('Run failed:', status.status);
								entityos.invoke('util-end', {data:
								{
									run: {error: status.status}
								}});
							}
						});

						poll();
					})
				})
				.catch(function(err)
				{
					console.error('Error creating thread:', err);

					entityos.invoke('util-end', {data:
					{
						vectorstore: {error: 'Error creating thread'}
					}});
				});
			}
		});
	}
}

