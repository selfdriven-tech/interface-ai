/*
	AI factory | GOOGLE | VERTEX AI

	For models like MedGemma

	https://chatgpt.com/share/684b5883-5674-800d-9f8c-53f62dafccb5

	// DON'T USE KEYS
	// DO FEDERATED BINDING -- SEE CHAT --
		gcloud iam workload-identity-pools create my-aws-pool \
			--location="global" \
			--display-name="AWS Lambda Pool"

	// gcloud auth application-default login for local

	gcloud iam service-accounts keys create key.json \
  		--iam-account=your-service-account@your-project.iam.gserviceaccount.com

	process.env.GOOGLE_APPLICATION_CREDENTIALS = './path/to/key.json';

	// Check auth
	const { auth } = require('google-auth-library');
		auth.getClient().then(client => {
		console.log('Authenticated with:', client.email || 'service account');
	});

	//

	const { VertexAI } = require('@google-cloud/vertexai');

	const vertexAI = new VertexAI({
	project: 'your-project-id',
	location: 'us-central1',
	});

	Option 1: Load Service Account Key JSON in Code

	const { VertexAI } = require('@google-cloud/vertexai');
	const { GoogleAuth } = require('google-auth-library');
	const fs = require('fs');

	// Load service account JSON
	const serviceAccount = JSON.parse(fs.readFileSync('./key.json', 'utf8'));

	// Create a custom auth client
	const auth = new GoogleAuth({
		credentials: serviceAccount,
		scopes: 'https://www.googleapis.com/auth/cloud-platform',
	});

	// Pass auth client into VertexAI
	const vertexAI = new VertexAI({
		project: 'your-project-id',
		location: 'us-central1',
		auth,
	});

	Option 2: Inline Credentials (if key is already in memory)

	const vertexAI = new VertexAI({
		project: 'your-project-id',
		location: 'us-central1',
		auth: new GoogleAuth({
			credentials: {
			client_email: 'xxx@project.iam.gserviceaccount.com',
			private_key: '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n',
			},
			scopes: 'https://www.googleapis.com/auth/cloud-platform',
		})
	});

	--

	const { VertexAI } = require('@google-cloud/vertexai');

	const project = 'your-project-id';
	const location = 'us-central1'; // or your region

	const vertexAI = new VertexAI({ project, location });

	function callVertexAI() {
	const model = 'text-bison'; // or 'gemini-1.5-pro-preview'

	const generativeModel = vertexAI.getGenerativeModel({
		model: model,
		generationConfig: {
		temperature: 0.7,
		maxOutputTokens: 256,
		},
		safetySettings: [
		{
			category: 'HARM_CATEGORY_DEROGATORY',
			threshold: 3,
		},
		],
	});

	const prompt = {
		contents: [{ role: 'user', parts: [{ text: 'Explain quantum computing simply.' }] }],
	};

	generativeModel
		.generateContent(prompt)
		.then(result => {
		const text = result.response.candidates[0].content.parts[0].text;
		console.log('RESPONSE:\n', text);
		})
		.catch(error => {
		console.error('ERROR:', error);
		});
	}

	callVertexAI();

*/

var entityos = require('entityos')
var _ = require('lodash')
var moment = require('moment');

module.exports = 
{
	VERSION: '1.0.0',

	init: function (param)
	{
		entityos.add(
		{
			name: 'ai-gen-util-chat',
			code: function (param)
			{
				const settings = entityos.get({scope: '_settings'});
                let aiSettings = _.get(param, 'settings');

				if (aiSettings == undefined)
				{
					aiSettings = entityos.invoke('ai-gen-util-get-settings');
				}

				let messages = _.get(param, 'messages', {});

				if (messages.system == undefined)
				{
					messages.system = _.get(settings, 'ai.defaults.messages.system');
				}

                if (messages == undefined)
                {
                    entityos.invoke('util-end', {error: 'No messages!'});
                }
                else
                {
					let keyPath = _.get(aiSettings, 'service.keypath');
					let apiKey = _.get(settings, keyPath);

					const { GoogleGenerativeAI } = require("@google/generative-ai");

					const googleGenerativeAI = new GoogleGenerativeAI(apiKey);

					console.log('model:' + aiSettings.model.name)
					const model = googleGenerativeAI.getGenerativeModel({ model: aiSettings.model.name });
					//"gemini-pro"

					let chatMessages = [];

					/*chatMessages.push(
					{
						role: "system",
						parts: [{ text: messages.system}]
					});*/

					const attachments = _.get(param, 'attachments');
									
					if (attachments != undefined)
					{
						_.each(attachments, function (attachment)
						{
							if (attachment.base64 != undefined)
							{
								chatMessages.push(
								{
									role: 'user',
									parts:
									[
										{text: messages.system + '. ' + messages.user},
										{
											inlineData:
											{
												mimeType: _.get(attachment, 'type', 'image/png'),
												data: attachment.base64
											}
										}
									]
								});
							}
						});
					}

					if (_.find(chatMessages, function (chatMessage) {return chatMessage.role == 'user'}) == undefined)
					{
						chatMessages.push({role: 'user', parts: [{text: messages.system + '. ' + messages.user}]})
					}

					console.log(chatMessages)

					const sendParam = {contents: chatMessages}

					console.log(sendParam)

					model.generateContent(sendParam)
					.then(function(result)
					{
						//console.log(result.response.text());
						_.set(param, 'messages.response',result.response.text());
						if (_.get(param, 'onComplete') != undefined)
						{
							entityos._util.onComplete(param)
						}
						else
						{
							entityos.invoke('util-end', param);
						}
					})
					.catch(console.error);
                }
			}
		});		
	}
}