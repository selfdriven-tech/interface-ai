/*
	AI factory | AWS BEDROCK

	//amazon.titan-text-lite-v1:
	{
		"inputText": "Your prompt here",
		"textGenerationConfig": {
			"maxTokenCount": 300,     // max tokens in the response
			"temperature": 0.7,
			"topP": 0.9,
			"stopSequences": ["\n"],  // optional
			"presencePenalty": 0.0,   // optional
			"frequencyPenalty": 0.0   // optional
		}
	}

	ADD Create Knowledge-Base
	PORT entityos to s3 from entity-aws repo
	https://aistudio.google.com/app/prompts?state=%7B%22ids%22:%5B%221Jjv1GhrWwTwlX1Apx73IUYn-7uC9gHYq%22%5D,%22action%22:%22open%22,%22userId%22:%22101750166633346939905%22,%22resourceKeys%22:%7B%7D%7D&usp=sharing
	See code below
*/

var entityos = require('entityos')
var _ = require('lodash')
var moment = require('moment');

module.exports = 
{
	VERSION: '1.0.0',

	init: function (param)
	{
		
		// Using Agent SDK
		// Responses API
		// https://platform.openai.com/docs/libraries
		// https://cookbook.openai.com/examples/file_search_responses
		// /DEV.md file in this repo.

		console.log('Loading AWS Factory...')

		entityos.add(
		{
			name: 'util-aws-get-config',
			code: function ()
			{
				const settings = entityos.get({scope: '_settings'});

				let accessID = _.get(settings, 'infrastructure.aws.access.id');
				let accessSecretKey = _.get(settings, 'infrastructure.aws.access.secret');

				if (accessID == 'prompt' || accessSecretKey == 'prompt')
				{
					const prompt = require('prompt-sync')();

					if (accessID == 'prompt')
					{
						const _accessID = prompt('AWS Access ID: ');
						_.set(settings, 'infrastructure.aws.access.id', _accessID);
					}

					if (accessSecretKey == 'prompt')
					{
						const _accessSecretKey = prompt('AWS Access Secret Key: ');
						_.set(settings, 'infrastructure.aws.access.secret', _accessSecretKey);
					}
				}

				process.env.AWS_ACCESS_KEY_ID = _.get(settings, 'infrastructure.aws.access.id');
				process.env.AWS_SECRET_ACCESS_KEY =  _.get(settings, 'infrastructure.aws.access.secret');

				const infrastructureConfig = 
				{
					credentials:
					{
						accessKeyId: _.get(settings, 'infrastructure.aws.access.id'),
						secretAccessKey: _.get(settings, 'infrastructure.aws.access.secret')
					},
					region: 'ap-southeast-2'
				}

				return infrastructureConfig;
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-service-models',
			code: function ()
			{	
				console.log('AWS Service Models...')

				let commandParams = {}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { BedrockClient, ListFoundationModelsCommand} = require("@aws-sdk/client-bedrock");

				const bedrock = new BedrockClient(infrastructureConfig);

				const command = new ListFoundationModelsCommand(commandParams);

				bedrock.send(command).then(function(response)
					{
						console.table(response.modelSummaries)

						const models = response.modelSummaries;
						
						let responseData =
						{
							models: models
						}

						entityos.invoke('util-end', responseData);
					}
				);
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-chat',
			notes: 'Model access @ https://ap-southeast-2.console.aws.amazon.com/bedrock/home?region=ap-southeast-2#/modelaccess',
			code: function (param)
			{
				const settings = entityos.get({scope: '_settings'});
				let aiSettings = _.get(param, 'settings');

				const maxTokensDefault = _.get(settings, 'ai.defaults.maxtokens', 1000);
				const temperatureDefault = _.get(settings, 'ai.defaults.temperature', 0.5);

				const maxTokensDefaultService = _.get(aiSettings, 'service.defaults.maxtokens', maxTokensDefault);
				const tempatureDefaultService = _.get(aiSettings, 'service.defaults.temperature', temperatureDefault);
					
				const maxTokens = _.get(param, 'maxTokens', maxTokensDefaultService);
				const temperature = _.get(param, 'temperature', tempatureDefaultService);

				let textGenerationConfig =
				{
					maxTokenCount: maxTokens,
					temperature: temperature
				}

				textGenerationConfig = _.assign(textGenerationConfig, _.get(param.modelSettings))

				let body =
				{
					inputText: _.get(param, 'param.messages.user', 'Hello?'),
					textGenerationConfig: textGenerationConfig
				};

				let commandParams =
				{
					modelId: _.get(param, 'model', 'amazon.titan-text-lite-v1'),
					contentType: "application/json",
					accept: "application/json",
					body: JSON.stringify(body),
				}

				const infrastructureConfig = entityos.invoke('util-aws-get-config');
			
				const { BedrockRuntimeClient, InvokeModelCommand } = require("@aws-sdk/client-bedrock-runtime");

				const bedrockRuntime = new BedrockRuntimeClient(infrastructureConfig);

				const command = new InvokeModelCommand(commandParams);

				bedrockRuntime.send(command)
				.then(function(response)
				{
					const _response = JSON.parse(Buffer.from(response.body).toString("utf-8"));
					//console.table(_response.inputTextTokenCount)
					//console.table(_response.results)

					_.set(param, 'messages.response', _response.results);

					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param);
					}
					else
					{
						entityos.invoke('util-end', param);
					}
				})
				.catch(function (responseError)
				{
					console.log(responseError)
					_.set(param, 'messages.response',  '!!: ' + _.get(responseError, 'error.message'));

					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param);
					}
					else
					{
						entityos.invoke('util-end', param);
					}
				});
			}
		});
	}
}

/*
import {
    BedrockAgentClient,
    CreateKnowledgeBaseCommand,
    CreateDataSourceCommand,
    StartIngestionJobCommand,
    GetIngestionJobCommand, // To check status
} from "@aws-sdk/client-bedrock-agent";
import { IAMClient, GetRoleCommand } from "@aws-sdk/client-iam"; // Optional: to fetch role ARN

// --- Configuration ---
const REGION = "us-east-1"; // Your AWS Region
const KB_NAME = "MyProgrammaticKB-Demo";
const KB_DESCRIPTION = "Knowledge Base created via Node.js SDK";

// Option 1: Hardcode Role ARN (if you know it)
// const KNOWLEDGE_BASE_ROLE_ARN = "arn:aws:iam::YOUR_ACCOUNT_ID:role/YourBedrockKnowledgeBaseRoleName";

// Option 2: Fetch Role ARN dynamically (if you only know the name)
const KNOWLEDGE_BASE_ROLE_NAME = "AmazonBedrockExecutionRoleForKnowledgeBase_Suffix"; // Replace with your actual role name

const EMBEDDING_MODEL_ARN = `arn:aws:bedrock:${REGION}::foundation-model/amazon.titan-embed-text-v1`; // Or cohere.embed-multilingual-v3 etc.
const S3_BUCKET_ARN = "arn:aws:s3:::your-bedrock-kb-source-bucket"; // Your S3 bucket ARN
const S3_BUCKET_NAME = "your-bedrock-kb-source-bucket"; // Just the bucket name
const S3_PREFIX = "documents/"; // Optional: if your files are in a specific folder within the bucket

// --- Initialize Clients ---
const bedrockAgentClient = new BedrockAgentClient({ region: REGION });
const iamClient = new IAMClient({ region: REGION }); // Only if fetching role ARN

async function getKBRoleArn(roleName) {
    try {
        const command = new GetRoleCommand({ RoleName: roleName });
        const response = await iamClient.send(command);
        return response.Role.Arn;
    } catch (error) {
        console.error(`Error fetching role ARN for ${roleName}:`, error);
        throw error;
    }
}


async function main() {
    let knowledgeBaseRoleArn;
    try {
        // If using KNOWLEDGE_BASE_ROLE_NAME to fetch ARN
        knowledgeBaseRoleArn = await getKBRoleArn(KNOWLEDGE_BASE_ROLE_NAME);
        // Or if KNOWLEDGE_BASE_ROLE_ARN is hardcoded, use that directly.
        // knowledgeBaseRoleArn = KNOWLEDGE_BASE_ROLE_ARN;

        if (!knowledgeBaseRoleArn) {
            console.error("Knowledge Base Role ARN could not be determined. Exiting.");
            return;
        }
        console.log("Using Knowledge Base Role ARN:", knowledgeBaseRoleArn);

        // 1. Create Knowledge Base
        console.log(`Creating Knowledge Base: ${KB_NAME}...`);
        const createKbCommand = new CreateKnowledgeBaseCommand({
            name: KB_NAME,
            description: KB_DESCRIPTION,
            roleArn: knowledgeBaseRoleArn,
            knowledgeBaseConfiguration: {
                type: "VECTOR",
                vectorKnowledgeBaseConfiguration: {
                    embeddingModelArn: EMBEDDING_MODEL_ARN,
                },
            },
            storageConfiguration: {
                type: "OPENSEARCH_SERVERLESS", // Bedrock will create and manage an OpenSearch Serverless collection
                opensearchServerlessConfiguration: {
                    // collectionArn: "OPTIONAL_ARN_IF_YOU_HAVE_AN_EXISTING_OSS_COLLECTION",
                    vectorIndexName: "bedrock-kb-index-" + KB_NAME.toLowerCase().replace(/[^a-z0-9-]/g, '-'), // Must be lowercase, no special chars
                    fieldMapping: {
                        vectorField: "bedrock-knowledge-base-default-vector", // Standard field name
                        textField: "AMAZON_BEDROCK_TEXT_CHUNK",         // Standard field name
                        metadataField: "AMAZON_BEDROCK_METADATA",       // Standard field name
                    },
                },
                // // Example for Pinecone:
                // type: "PINECONE",
                // pineconeConfiguration: {
                //   connectionString: "YOUR_PINECONE_CONNECTION_STRING_ENDPOINT_URL",
                //   credentialsSecretArn: "ARN_OF_SECRET_MANAGER_SECRET_FOR_PINECONE_API_KEY",
                //   fieldMapping: {
                //     textField: "text",
                //     metadataField: "metadata"
                //   },
                //   // namespace: "optional-pinecone-namespace"
                // }
                // // Example for Redis Enterprise Cloud
                // type: "REDIS_ENTERPRISE_CLOUD",
                // redisEnterpriseCloudConfiguration: {
                //   endpoint: "YOUR_REDIS_ENDPOINT_URL_WITHOUT_PORT",
                //   vectorIndexName: "my-redis-index",
                //   credentialsSecretArn: "ARN_OF_SECRET_MANAGER_SECRET_FOR_REDIS_PASSWORD",
                //   fieldMapping: {
                //     vectorField: "vector",
                //     textField: "text",
                //     metadataField: "metadata"
                //   }
                // }
            },
        });

        const kbResponse = await bedrockAgentClient.send(createKbCommand);
        const knowledgeBaseId = kbResponse.knowledgeBase.knowledgeBaseId;
        console.log("Knowledge Base created successfully! ID:", knowledgeBaseId);
        console.log("KB ARN:", kbResponse.knowledgeBase.knowledgeBaseArn);
        console.log("Status:", kbResponse.knowledgeBase.status); // Should be CREATING or ACTIVE

        // Wait for KB to become ACTIVE (simplified polling, in production use a more robust waiter)
        // This is often very fast, but good practice for subsequent steps.
        let kbStatus = kbResponse.knowledgeBase.status;
        while (kbStatus === 'CREATING') {
            console.log('Waiting for Knowledge Base to become ACTIVE...');
            await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
            const { GetKnowledgeBaseCommand } = await import("@aws-sdk/client-bedrock-agent");
            const statusResponse = await bedrockAgentClient.send(new GetKnowledgeBaseCommand({ knowledgeBaseId }));
            kbStatus = statusResponse.knowledgeBase.status;
            console.log('KB Status:', kbStatus);
        }

        if (kbStatus !== 'ACTIVE') {
            console.error(`Knowledge Base creation failed or stuck in status: ${kbStatus}`);
            return;
        }


        // 2. Create Data Source
        console.log(`Creating Data Source for KB ${knowledgeBaseId}...`);
        const dataSourceName = `s3-source-${KB_NAME}`;
        const s3Configuration = {
            bucketArn: S3_BUCKET_ARN,
        };
        if (S3_PREFIX) {
            s3Configuration.inclusionPrefixes = [S3_PREFIX.endsWith('/') ? S3_PREFIX : S3_PREFIX + '/'];
        }

        const createDsCommand = new CreateDataSourceCommand({
            knowledgeBaseId: knowledgeBaseId,
            name: dataSourceName,
            description: `S3 data source for ${KB_NAME}`,
            dataSourceConfiguration: {
                type: "S3",
                s3Configuration: s3Configuration,
            },
            // Optional: Define chunking strategy if default isn't suitable
            // vectorIngestionConfiguration: {
            //   chunkingConfiguration: {
            //     chunkingStrategy: "FIXED_SIZE",
            //     fixedSizeChunkingConfiguration: {
            //       maxTokens: 512,
            //       overlapPercentage: 20
            //     }
            //   }
            // }
        });

        const dsResponse = await bedrockAgentClient.send(createDsCommand);
        const dataSourceId = dsResponse.dataSource.dataSourceId;
        console.log("Data Source created successfully! ID:", dataSourceId);
        console.log("DS Status:", dsResponse.dataSource.status); // Should be AVAILABLE


        // 3. Start Ingestion Job
        console.log(`Starting Ingestion Job for KB ${knowledgeBaseId}, DS ${dataSourceId}...`);
        const startIngestionCommand = new StartIngestionJobCommand({
            knowledgeBaseId: knowledgeBaseId,
            dataSourceId: dataSourceId,
            description: `Initial ingestion for ${dataSourceName}`,
        });

        const ingestionResponse = await bedrockAgentClient.send(startIngestionCommand);
        const ingestionJobId = ingestionResponse.ingestionJob.ingestionJobId;
        console.log("Ingestion Job started successfully! Job ID:", ingestionJobId);
        console.log("Ingestion Job Status:", ingestionResponse.ingestionJob.status); // Should be STARTING

        // Optional: Poll for Ingestion Job completion
        let jobStatus = ingestionResponse.ingestionJob.status;
        while (jobStatus === 'STARTING' || jobStatus === 'IN_PROGRESS') {
            console.log(`Ingestion Job ${ingestionJobId} status: ${jobStatus}. Waiting...`);
            await new Promise(resolve => setTimeout(resolve, 30000)); // Poll every 30 seconds

            const getIngestionJobCommand = new GetIngestionJobCommand({
                knowledgeBaseId: knowledgeBaseId,
                dataSourceId: dataSourceId,
                ingestionJobId: ingestionJobId,
            });
            const jobDetails = await bedrockAgentClient.send(getIngestionJobCommand);
            jobStatus = jobDetails.ingestionJob.status;

            if(jobDetails.ingestionJob.statistics) {
                console.log('Scanned:', jobDetails.ingestionJob.statistics.numberOfDocumentsScanned,
                            'Processed:', jobDetails.ingestionJob.statistics.numberOfDocumentsProcessed,
                            'Deleted:', jobDetails.ingestionJob.statistics.numberOfDocumentsDeleted,
                            'Failed:', jobDetails.ingestionJob.statistics.numberOfFailedDocuments);
            }
        }
        console.log(`Ingestion Job ${ingestionJobId} finished with status: ${jobStatus}`);
        if(jobStatus === 'FAILED' && ingestionResponse.ingestionJob.failureReasons){
            console.error("Ingestion failed. Reasons:", ingestionResponse.ingestionJob.failureReasons);
        }


    } catch (error) {
        console.error("An error occurred:", error);
        if (error.name === 'ValidationException') {
            console.error("Validation Error Details:", error.message);
        }
    }
}

main();
*/